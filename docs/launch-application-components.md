# Deploying application on Kubernetes Cluster

## Create the Secret for application configuration

Create a Secret including Spring-Boot environment-specific configuration file:
```
$ kubectl create secret generic sample-app-cfg \
    --from-file=./etc/sample-app/application-kubernetes.yaml
```
## Create EBS volume for persitent data

Create EBS volume for H2 data
```
$ aws ec2 create-volume --size 1 --availability-zone $KUBE_AWS_ZONE --volume-type standard
{
    "AvailabilityZone": "eu-west-1c",
    "Encrypted": false,
    "VolumeType": "standard",
    "VolumeId": "vol-901a5821",
    "State": "creating",
    "SnapshotId": "",
    "CreateTime": "2016-08-22T10:55:45.663Z",
    "Size": 1
}
```

Take note of `VolumeId`. We need it in the next step.

## Create H2 server Service

Before creating the Service, you have to edit manually `k8s/h2server-deployment.yaml` and match your VolumeId and DockerHub account name.

Replace:
- `<VOLUME-ID>` with the VolumeId you just created
- `<DOCKERHUB-ACCOUNT>` with the name of your DockerHub account

## Create H2 Server Deployment

To launch H2 Server we are using a [http://kubernetes.io/docs/user-guide/deployments/](Deployment).

(No need to edit the spec file before creating it)
```
$ kubectl create -f k8s/h2server-deployment.yaml
```

## Create an (internal) H2 Service

To make H2 Server accessible from other Pods, we have to expose it internally as a Service.

As the Cluster is using the [http://kubernetes.io/docs/admin/dns/](DNS add-on), other Pods will be able to discover it using the DNS name (= Service name).

```
$ kubectl create -f k8s/h2server-svc.yaml
```

## (Optional) Expose H2 web UI

To access the H2 Web UI, you have to expose it, externally, as a Service with a Load Balancer.

K8s AWS provider will automatically create an external ELB with a public DNS name.

```
$ kubectl create -f k8s/h2server-webui-svc.yaml
service "h2server-ui" created
```

Descrive the Service to get the public DNS name:
```
$ kubectl describe svc h2server-ui
Name:              h2server-ui
Namespace:             default
Labels:            <none>
Selector:              name=h2server
Type:              LoadBalancer
IP:                10.0.13.182
LoadBalancer Ingress:      a8263d986693011e6a24f0aa73e55bfa-1258493660.eu-west-1.elb.amazonaws.com
Port:              <unset>    80/TCP
NodePort:              <unset>    32413/TCP
Endpoints:             10.244.0.3:81
Session Affinity:          None
```

When the ELB is fully working you can access the Web UI from the browser at the ELB public DNS name (`a8263d986693011e6a24f0aa73e55bfa-1258493660.eu-west-1.elb.amazonaws.com` in the example). To connect to the database from the UI use this JDBC URL: `jdbc:h2:tcp://h2server:1521/hateoas-sample`. AWS takes a while (minutes!) to connect Instances to the ELB.

Note the database is still empty, as sample data will be generated by the application.

### Note about security

H2 Web UI is not secured AT ALL. *Do not expose it unless you have secured your AWS VPC not to be accessible from the Internet* (see [docs/notes-about-security.md](Notes about security))


## Launch the Sample Application as Pod

Before launching the sample application properly, using a Deployment, we are going to run it as a standalone Pod. This step is not strictly required but is included in the tutorial to show the difference between running a standalone Pod and a Deployment. Note that the spec file of the standalone Pod ([k8s/sample-app-pod.yaml](sample-app-pod.yaml)) sets the env variable `SAMPLE_DATA=true` to load sample data into the database, while the Deployment spec doesn't load any data.

Before creating the Pod, you have to edit `k8s/sample-app-pod.yaml` replacing `<DOCKERHUB-ACCOUNT>` with the name of your DockerHub account

Create the Pod:
```
$ kubectl create -f k8s/sample-app-pod.yaml
```

Watch the Pod starting:
```
$ kubectl get pods
```


## Publish the application API

To expose the sample application API, we have to create a Service with a Load Balancer. The Service also creates an AWS external ELB with a public DNS name we may use from the Internet (please, also see [docs/notes-about-security.md](Notes about security)).

Create FrontEnd Service and Load Balancer:
```
$ kubectl create -f k8s/frontend-svc.yaml
```

Describe Service to get external LB DNS name:
```
$ kubectl describe svc frontend
Name:              frontend
Namespace:  default
Labels:            <none>
Selector:   name=sample-app
Type:              LoadBalancer
IP:                10.0.200.84
LoadBalancer Ingress:      aeb778c57687411e6b0e80a720f796de-1966482204.eu-west-1.elb.amazonaws.com
Port:              <unset>    80/TCP
```

Take note of Load Balancer Ingress DNS name and ELB Name (the trailing part of DNS name up to the first hyphen).

It takes a while (minutes!) to have the ELB fully working and attached to the running instances. To monitor ELB status, you may use an AWS CLI command and wait until all Instances are *InService*:
```
$ aws elb describe-instance-health --load-balancer-name <elb-name>
```

## Verify the application is working

Now we may use the sample application API, exposed through the ELB just created:
```
$ curl http://<frontend-load-balancer-dns-name>/books
```


## Redeploy the application using a Deployment

Now we are sure everything works, we may remove the standalone Pod and redeploy the application with a Deployment.

Delete Sample App Pod:
```
$ kubectl delete pod sample-app
```

Before creating the Deployment, you have to edit `k8s/frontend-deployment.yaml` and replace `<DOCKERHUB-ACCOUNT>` with the name of your DockerHub account.

Create *frontend* Deployment:
```
$ kubectl create -f k8s/frontend-deployment.yaml
deployment "frontend" created
```

Remember the Deployment specs file DO NOT make the application loading sample data on start.

Monitor deployment rollout:
```
$ kubectl rollout status deployment/frontend
```

Monitor Pods coming up:
```
$ kubectl get pods
```
